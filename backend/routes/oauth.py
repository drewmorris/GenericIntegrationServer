from __future__ import annotations

from fastapi import APIRouter, HTTPException, Query, Request, Depends
from starlette.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Annotated  # noqa: F401
import uuid
import os
import json
from urllib.parse import urlparse
import logging

# Defer heavy Onyx imports to runtime inside endpoints to avoid import-time side effects in tests

from backend.db.session import get_db
from backend.db import models as m
from backend.security.crypto import encrypt_dict

try:
    import redis  # type: ignore
except Exception:  # noqa: BLE001
    redis = None  # type: ignore

router = APIRouter(prefix="/oauth", tags=["OAuth"])
logger = logging.getLogger(__name__)

_state_mem: dict[str, dict] = {}


def _get_base_domain(request: Request) -> str:
    return f"{request.url.scheme}://{request.url.netloc}"


def _get_redis():
    if redis is None:
        return None
    url = os.getenv("REDIS_URL") or os.getenv("CELERY_BROKER_URL")
    if url and url.startswith("redis://"):
        try:
            return redis.Redis.from_url(url)
        except Exception:  # noqa: BLE001
            return None
    return None


def _is_allowed(url: str | None) -> bool:
    if not url:
        return True
    allowed = os.getenv("OAUTH_ALLOWED_REDIRECT_HOSTS", "")
    if not allowed:
        # default allow only same-origin
        return True
    host = urlparse(url).netloc
    return any(h and h.strip() == host for h in allowed.split(","))


@router.get("/{connector}/start", summary="Start OAuth flow", description="Return the provider authorization URL to redirect the user.")
async def oauth_start(
    request: Request,
    connector: str,
    state: str = Query(..., description="Opaque CSRF token generated by client"),
    organization_id: uuid.UUID = Query(...),
    user_id: uuid.UUID = Query(...),
    redirect_uri: str | None = Query(default=None),
    next: str | None = Query(default=None, description="UI URL to redirect to after callback"),
    code_challenge: str | None = Query(default=None),
    code_challenge_method: str | None = Query(default=None),
    code_verifier: str | None = Query(default=None),
):
    if not state or len(state) < 8:
        raise HTTPException(status_code=400, detail="Invalid state")
    if not _is_allowed(next):
        raise HTTPException(status_code=400, detail="Disallowed next URL host")
    if redirect_uri and not _is_allowed(redirect_uri):
        raise HTTPException(status_code=400, detail="Disallowed redirect_uri host")

    # Lazy import Onyx connector runtime
    try:
        from connectors.onyx.configs.constants import DocumentSource  # type: ignore
        from connectors.onyx.connectors.interfaces import OAuthConnector  # type: ignore
        from connectors.onyx.connectors.factory import identify_connector_class  # type: ignore
        src = getattr(DocumentSource, connector.upper())
        conn_cls = identify_connector_class(src)
        if not issubclass(conn_cls, OAuthConnector):
            raise HTTPException(status_code=400, detail="Connector does not support OAuth")
    except Exception as exc:  # noqa: BLE001
        raise HTTPException(status_code=404, detail="Connector not found or OAuth not supported") from exc

    base_domain = _get_base_domain(request)
    additional_kwargs: dict[str, str] = {}
    if redirect_uri:
        additional_kwargs["redirect_uri"] = redirect_uri
    if code_challenge and code_challenge_method:
        additional_kwargs["code_challenge"] = code_challenge
        additional_kwargs["code_challenge_method"] = code_challenge_method

    # store state â†’ org/user (+ pkce verifier) for callback validation
    data = {"organization_id": str(organization_id), "user_id": str(user_id), "connector": connector, "next": next}
    if code_verifier:
        data["code_verifier"] = code_verifier
    r = _get_redis()
    if r is not None:
        try:
            r.setex(f"gis:oauth:state:{state}", 600, json.dumps(data))
        except Exception:  # noqa: BLE001
            _state_mem[state] = data
    else:
        _state_mem[state] = data

    auth_url = conn_cls.oauth_authorization_url(base_domain, state, additional_kwargs)
    logger.info("oauth_start connector=%s org=%s user=%s next=%s method=%s", connector, organization_id, user_id, next, additional_kwargs.get("code_challenge_method"))
    return {"authorization_url": auth_url}


@router.get("/{connector}/callback", summary="OAuth callback", description="Handle provider callback, exchange code for tokens, and persist credentials.")
async def oauth_callback(
    request: Request,
    connector: str,
    code: str = Query(...),
    state: str = Query(...),
    organization_id: uuid.UUID | None = Query(default=None),
    user_id: uuid.UUID | None = Query(default=None),
    redirect_uri: str | None = Query(default=None),
    db: AsyncSession = Depends(get_db),
):
    try:
        from connectors.onyx.configs.constants import DocumentSource  # type: ignore
        from connectors.onyx.connectors.interfaces import OAuthConnector  # type: ignore
        from connectors.onyx.connectors.factory import identify_connector_class  # type: ignore
        src = getattr(DocumentSource, connector.upper())
        conn_cls = identify_connector_class(src)
        if not issubclass(conn_cls, OAuthConnector):
            raise HTTPException(status_code=400, detail="Connector does not support OAuth")
    except Exception as exc:  # noqa: BLE001
        raise HTTPException(status_code=404, detail="Connector not found or OAuth not supported") from exc

    # resolve state
    resolved_org = organization_id
    resolved_user = user_id
    r = _get_redis()
    stored = None
    if r is not None:
        try:
            val = r.get(f"gis:oauth:state:{state}")
            if val:
                stored = json.loads(val)
                r.delete(f"gis:oauth:state:{state}")
        except Exception:  # noqa: BLE001
            stored = _state_mem.pop(state, None)
    else:
        stored = _state_mem.pop(state, None)

    if stored:
        resolved_org = uuid.UUID(stored["organization_id"])  # type: ignore[arg-type]
        resolved_user = uuid.UUID(stored["user_id"])  # type: ignore[arg-type]
        code_verifier = stored.get("code_verifier") if isinstance(stored, dict) else None
    else:
        code_verifier = None

    if resolved_org is None or resolved_user is None:
        raise HTTPException(status_code=400, detail="Missing organization_id/user_id for OAuth callback")

    base_domain = _get_base_domain(request)
    additional_kwargs: dict[str, str] = {"state": state}
    if redirect_uri and _is_allowed(redirect_uri):
        additional_kwargs["redirect_uri"] = redirect_uri
    if code_verifier:
        additional_kwargs["code_verifier"] = code_verifier

    try:
        token_dict = conn_cls.oauth_code_to_token(base_domain, code, additional_kwargs)
    except Exception as exc:  # noqa: BLE001
        raise HTTPException(status_code=400, detail=f"Token exchange failed: {exc}") from exc

    cred = m.Credential(
        id=uuid.uuid4(),
        organization_id=resolved_org,
        user_id=resolved_user,
        connector_name=connector,
        provider_key="oauth",
        credential_json=encrypt_dict(token_dict),
    )
    db.add(cred)
    await db.commit()
    await db.refresh(cred)
    logger.info("oauth_callback connector=%s org=%s user=%s credential_id=%s", connector, resolved_org, resolved_user, cred.id)
    if stored and isinstance(stored, dict) and stored.get("next"):
        # Redirect back to UI with credential_id
        if _is_allowed(stored["next"]):
            return RedirectResponse(url=f"{stored['next']}?credential_id={cred.id}", status_code=302)
    return {"credential_id": str(cred.id)} 